<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Veljko Petrović">
  <title>OpenMP</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/night.css" id="theme">
  <link rel="stylesheet" href="slides.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">OpenMP</h1>
  <p class="author">Veljko Petrović</p>
  <p class="date">v1.1.0</p>
</section>

<section>
<section id="openmp" class="title-slide slide level1">
<h1>OpenMP</h1>
<p>Model deljene memorije</p>
</section>
<section id="log-promena" class="slide level2">
<h2>Log promena</h2>
<ul>
<li>v1.1.0 - Ispravljena štamparska greška u navođenju redukcija i
dodata sekcija o posebnim redukcijama</li>
<li>v1.0.0 - Aktuelna verzija u Novembru 2023</li>
</ul>
</section>
<section id="šta-je-openmp" class="slide level2">
<h2>Šta je OpenMP</h2>
<ul>
<li>Ovo bi sve trebali da već znate.</li>
<li>No, dovoljno je bitno da pređemo ponovo.</li>
<li>OpenMP je ‘Open MultiProcessing’</li>
<li>Centralna ideja je deljena memorija i više niti izvršavanja</li>
<li>Nekada davno, svo paralelno programiranje je bilo ovako.</li>
<li>Ovo je i dalje stil programiranja koji je najčešći u korisničkim
aplikacijama zato što se izvršavaju na jednoj mašini, bez obzira koliko
procesora ima.</li>
<li>Sam jezik je C/C++ mada OpenMP postoji i za Fortran.</li>
</ul>
</section>
<section id="arhitektura-openmp" class="slide level2">
<h2>Arhitektura OpenMP</h2>
<ul>
<li>Glavna jedinica podele izvršavanja u OpenMP je nit (thread)</li>
<li>Niti se mogu podeliti u:
<ul>
<li>Glavnu</li>
<li>Niti radilice (worker threads)</li>
</ul></li>
<li>Svaka nit je nezavisna traka izvršavanja koja prolazi kroz
program</li>
<li>Ono što odlikuje glavnu nit jeste što počinje prva i što njeno
završavanje završava program. Glavna nit takođe pokreće, zaustavlja i
kontroliše niti-radilice.</li>
<li>Način na koji se ovakvo ponašanje postiže jeste kroz OpenMP
direktive.</li>
</ul>
</section>
<section id="koliko-niti" class="slide level2">
<h2>Koliko niti?</h2>
<ul>
<li>Koliko mi hoćemo.</li>
<li>U praksi, broj niti jako zavisi od naše svrhe. Ako imamo više niti
da bi u stvari efektno čekali na više stvari istovremeno zato što smo u
sistemu koji je I/O ograničen onda je broj niti neograničen, odnosno,
samo ograničen sposobnošću sistema da to istrpi.</li>
<li>Ovako rade sistemi, npr. web servera ili sistemi koji rade sa
velikim brojem operacija nad fajlovima.</li>
<li>Ovako, takođe, rade sistemi koji hoće da pruže glatko interaktivno
iskustvo dok nešto rade u pozadini: onda obično postoji jedna GUI nit i
više niti-radilica.</li>
<li>Neki visoko interaktivni sistemi dodeljuju niti zadacima. Tipičan
primer su video igre gde obično imate podelu tipa: nit za iscrtavanje,
nit za kontrolu, nit za zvuk i nit za veštačku inteligenciju, u
zavisnosti od prirode engine-a koji se koristi.</li>
</ul>
</section>
<section id="koliko-niti-1" class="slide level2">
<h2>Koliko niti?</h2>
<ul>
<li>Ovde, naš cilj je maksimum brzine stoga je pravilo mnogo
jednostavnije.</li>
<li>Broj OpenMP niti treba da bude manji ili jednak ukupnom broju
sistemskih niti na raspolaganju.</li>
<li>Sistemske niti su ravne broju ‘procesora’ u kontekstu SLURM-a, tj.
broju stvari koje procesor(i) u sistemu mogu da rade istovremeno.</li>
<li>Što ne više? Zato što se paralelizam preko hardverske granice
ostvaruje koristeći preemptivno izvršavanje što znači da umesto da
dobijamo na ukupnoj ostvarenoj brzini mi je gubimo na context-switching
overhead.</li>
</ul>
</section>
<section id="fork-join-metod-izvršavanja" class="slide level2">
<h2>Fork-join metod izvršavanja</h2>
<p><img data-src="forkjoin.png" /></p>
</section>
<section id="fork-join-metod-izvršavanja-1" class="slide level2">
<h2>Fork-join metod izvršavanja</h2>
<ul>
<li>Program počinje izvršavajući samo jednu stvar, sekvencijalno.</li>
<li>U nekim trenucima, stvara se veći broj dodatnih niti izvršavanja
(račvanje).</li>
<li>Te niti izvršavanja se izvode nezavisno sve dok se ne priključe
ponovo glavnoj niti kroz formu implicitne sinhronizacije barijerom.</li>
</ul>
</section>
<section id="spmd" class="slide level2">
<h2>SPMD</h2>
<ul>
<li>Najčešća forma koji fork/join paralelizam ima u okviru OpenMP-a
jeste Single Program Multiple Data, praktični rođak SIMD arhitekture
koji smo pominjali pre par časova.</li>
<li>To znači da svaka od niti izvršava isti kod koga samo razlikuju za
nit specifične privatne promenljive (više o ovome kasnije).</li>
<li>Ovo je onda način da podelimo posao na iste komade.</li>
</ul>
</section>
<section id="alternative-spmd" class="slide level2">
<h2>Alternative SPMD</h2>
<ul>
<li>OpenMP je jednako lako konfigurisati da paralelno izvršava različite
komade koda.</li>
<li>Ponekad algoritam ovo zahteva, mada to nije nužno dobra ideja.</li>
<li>Heterogen paralelni kod se ne uklapa tako glatko u fork/join
arhitekturu zbog toga što je vreme izvršavanja nepredvidivo što znači da
join može da ima nepredvidivu količinu čekanja da se izvršavanje
sinhronizuje.</li>
<li>Najbolje je ovo prilagoditi kontekstu algoritma.</li>
</ul>
</section>
<section id="ugnježden-paralelizam" class="slide level2">
<h2>Ugnježden paralelizam</h2>
<ul>
<li>Moguće je račvati nit izvršavanja unutar već račvane niti
izvršavanja.</li>
<li>Tj. fork unutar fork-a.</li>
<li>Kako se ovo izvrši zavisi od toga kako je OpenMP implementacija koja
se koristi implementirana.</li>
<li>Neke ignorišu dublje slojeve paralelizacije i tretiraju ih kao
sekvencijalan kod, a neki izvršavaju kako je napisano dok god ima
neiskorišćenih sistemskih niti.</li>
<li>Ovakva forma ugnježdavanja je korisna ili u specijalizovanim
algoritmima ili kada imamo računar sa jako puno paralelnih niti, možda
neki čvor sa četiri EPYC</li>
</ul>
</section>
<section id="promenljive-niti" class="slide level2">
<h2>Promenljive niti</h2>
<ul>
<li>OpenMP je baziran na modelu deljene memorije.</li>
<li>Podrazumevano je da sve promenljive budu deljene tj. da svaka nit
može da im pristupi.</li>
<li>Određene promenljive, sa druge strane, mogu da budu podeljene tako
da svaka nit ima svoj primerak.</li>
<li>Ovo bi moglo da se uradi i ručno, tako što imamo nekakvu strukturu
podatka gde se promenljive indeksiraju kroz broj niti, ali OpenMP to
omogućava automatski.</li>
<li>Neke promenljive nisu ni privatne ni globalne, doduše, no mešaju ta
dva pristupa. Ovo je od koristi kada se rade operacije redukcije, o čemu
više kasnije.</li>
</ul>
</section>
<section id="sistemske-promenljive-i-openmp" class="slide level2">
<h2>Sistemske promenljive i OpenMP</h2>
<ul>
<li>OpenMP gleda vrednosti sistemskih promenljivih ne bi li odredio
svoje ponašanje.</li>
<li>Sistemske promenljive mogu biti nameštene:
<ul>
<li>U profilu korisnika.</li>
<li>U skripti koja pokreće aplikaciju.</li>
<li>Na komandnoj liniji.</li>
</ul></li>
</ul>
</section>
<section id="sistemske-promenljive-i-openmp-1" class="slide level2">
<h2>Sistemske promenljive i OpenMP</h2>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Promenljiva</th>
<th>Tip vrednosti</th>
<th>Značenje</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OMP_NUM_THREADS</td>
<td>Broj</td>
<td>Broj istovremenih niti</td>
</tr>
<tr class="even">
<td>OMP_DYNAMIC</td>
<td>Bulova</td>
<td>Dinamički menja broj istovremenih niti. Može povećati efikasnost
kroz adaptaciju, ali ima cenu u performansama.</td>
</tr>
<tr class="odd">
<td>OMP_SCHEDULE</td>
<td>Reč.Broj</td>
<td>Tip rasporeda izvršavanja praćen dimenzijom particije izvršavanja.
Više o tome kasnije.</td>
</tr>
<tr class="even">
<td>OMP_NESTED</td>
<td>Bulova</td>
<td>Da li imamo ugnježdeni paralelizam ili ne. Može da nam pomogne da
upravljamo distribucijom niti u komplikovanim situacijama, ali ima
fiksnu cenu u overhead-u.</td>
</tr>
</tbody>
</table>
</section>
<section id="sistemske-promenljive-i-openmp-2" class="slide level2">
<h2>Sistemske promenljive i OpenMP</h2>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 22%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Promenljiva</th>
<th>Tip vrednosti</th>
<th>Značenje</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OMP_CANCELLATION</td>
<td>Bulova</td>
<td>Da li ‘cancel’ direktiva radi ili ne.</td>
</tr>
<tr class="even">
<td>OMP_MAX_ACTIVE_LEVELS</td>
<td>Broj</td>
<td>Koliko ugnježdenih regiona je dozvoljeno. Podrazumevano je da je
neograničeno.</td>
</tr>
<tr class="odd">
<td>OMP_MAX_TASK_PRIORITY</td>
<td>Broj</td>
<td>Najveći sistemski prioritet koji se dodeljuje zadacima.</td>
</tr>
<tr class="even">
<td>OMP_STACKSIZE</td>
<td>Broj praćen sa B, K, M, ili G</td>
<td>Veličina sistemskog steka za jednu nit izvršavanja</td>
</tr>
</tbody>
</table>
</section>
<section id="bibliotečke-rutine" class="slide level2">
<h2>Bibliotečke rutine</h2>
<ul>
<li>OpenMP se sastoji od: sistemskog okruženja izvršavanja, biblioteka,
i direktiva.</li>
<li>Biblioteke su klasične C biblioteke i nude funkcionalnost aplikacije
kroz funkcije.</li>
<li>Fajl zaglavlja za C biblioteku je <code>omp.h</code></li>
</ul>
</section>
<section id="bibliotečke-rutine-1" class="slide level2">
<h2>Bibliotečke rutine</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n <span class="op">=</span> omp_get_num_threads<span class="op">();</span> <span class="co">// koliko ima niti</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> k <span class="op">=</span> omp_get_thread_num<span class="op">();</span> <span class="co">// koja je tekuća nit koja ovo izvršava</span></span></code></pre></div>
<p>Primetite <code>omp_</code> prefiks i snake case imena umesto camel
case</p>
</section>
<section id="čemu-direktive" class="slide level2">
<h2>Čemu direktive?</h2>
<ul>
<li>OpenMP ima nezavidan zadatak</li>
<li><code>C</code> je fundamentalno napravljen sa idejom jednostrukog
izvršavanja</li>
<li>To je ugrađeno u sam jezik</li>
<li>Većina sistema za paralelnog izvršavanje radi tako što nas tera da
eksplicitno pravimo strukture podataka koje predstavljaju jedinice
paralelnog izvršavanja, te ih pokrećemo sami.</li>
<li>Ovo čini takav kod izuzetno nezgodnim za praćenje.</li>
<li>Razmišljajte o, recimo, Pthread tehnologiji</li>
</ul>
</section>
<section id="pthreads" class="slide level2">
<h2>Pthreads</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> inc_x<span class="op">(</span><span class="dt">void</span><span class="op">*</span> void_ptr<span class="op">){</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span><span class="op">*</span> x_ptr <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span>void_ptr<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span><span class="op">(++(*</span>x_ptr<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;Inkrementacija gotova</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span></code></pre></div>
</section>
<section id="užas" class="slide level2">
<h2>Užas</h2>
<ul>
<li>Ovo je užasavajuće sa tačke gledišta dobrog programiranja</li>
<li>Prvo, koristimo void pokazivače za sve: to je užasno samo po
sebi</li>
<li>Drugo, imamo funkciju, nešto što karakteriše ulaz i izlaz, koja nema
nikakav izlaz nego samo modifikuje stanje preko nekontrolisanog
pokazivača</li>
</ul>
</section>
<section id="pthreads-1" class="slide level2">
<h2>Pthreads</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  pthread_t inc_x_thread<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>pthread_create<span class="op">(&amp;</span>inc_x_thread<span class="op">,</span> NULL<span class="op">,</span> inc_x<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">)){</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;Ne mogu da napravim nit</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span><span class="op">(++</span>y <span class="op">&lt;</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;Inkrementacija Y gotova.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>pthread_join<span class="op">(</span>inx_x_thread<span class="op">,</span> NULL<span class="op">)){</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;Ne mogu da sačekam nit</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;x: </span><span class="sc">%d</span><span class="st">, y: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="užas-2-užas-uzvraća-udarac" class="slide level2">
<h2>Užas 2: Užas uzvraća udarac</h2>
<ul>
<li>Primetite kako smo potpuno invertovali tok programa: sve vreme
moramo sa nitima da radimo kao sa rukavicama, sve vreme moramo da rukom
proveravamo ishod niti, dve niti koje bi trebale da rade istu stvar u
stvari imaju drugi tok koda, sve u svemu ovo se teško piše, teško čita,
i može da krije bagove vrlo lako.</li>
<li>Šta je problem? Nekompatibilne paradigme.</li>
</ul>
</section>
<section id="šta-je-alternativa" class="slide level2">
<h2>Šta je alternativa?</h2>
<ul>
<li>Pa i nema je baš.</li>
<li>Problem je u tome što C nije napravljen da bude proširiv.</li>
<li>Ako konstrukti ugrađeni u jezik ne zadovoljavaju naš obrazac
programiranja nema mnogo toga što možemo da uradimo.</li>
<li>Možemo da koristimo pre-procesor da modifikujemo kod pre nego stigne
kod kompajlera.</li>
<li>Ovakav pristup vrlo uspešno koristi, npr. Qt koji dodaje konstrukte
u C++ koji prvobitno nisu bili tu.</li>
<li>Problem sa tim jeste što kod koji se zaista izvršava (i kod koji
posle moramo da debagujemo) nema baš puno veze sa onim što smo napisali.
Ovo je generator glavobolja.</li>
</ul>
</section>
<section id="foss-rešenje" class="slide level2">
<h2>FOSS rešenje</h2>
<ul>
<li>GCC je open source.</li>
<li><code>git clone git@github.com:gcc-mirror/gcc.git</code> i već se
bavimo razvojem kompajlera.</li>
<li>Zašto jednostavno ne proširiti C funkcionalnošću koja nam
treba?</li>
<li>Zato što to onda nije više standardni C.</li>
<li>Suptilne nekompatibilnosti između standarda i implementacije su
odgovorne za neverovatne komplikacije. Plus, naš kod je sada zauvek
vezan za tu, modifikovanu verziju GCC-a.</li>
<li>Može li bolje?</li>
</ul>
</section>
<section id="pragma" class="slide level2">
<h2><code>#pragma</code></h2>
<ul>
<li><code>#pragma</code> je jednostavna ideja</li>
<li>To je način da se direktno obratimo kompajleru i damo nekakve
instrukcije.</li>
<li><code>#pragma</code> direktive su eksplicitno tu da budu
nestandardne: svaki kompajler je potpuno slobodan da doda bilo koji broj
svojih pragmi koje rade šta god taj kompajler hoće.</li>
<li><em>…sve dok ignorišu sve pragme koje ne znaju šta rade. </em></li>
<li>Ovo je tajni sastojak koji omogućava proširivost. Naš kod je i dalje
legalan čak i ako je pun pragmi: kompajler koji ih ne podržava će samo
da ih ignoriše i sve će i dalje da radi.</li>
</ul>
</section>
<section id="gcc-i-openmp-podrška" class="slide level2">
<h2>gcc i openMP podrška</h2>
<ul>
<li>Da li moramo onda da modifikujemo GCC?</li>
<li>Naravno da ne, neko je već bio fin i to uradio umesto nas.</li>
<li>Sve što je neophodno jeste da kompajliramo naš kod sa opcijom
-fopenmp i dobijemo svu OpenMP podršku koja nam treba, a bibliotečke
funkcije pruža libgomp</li>
</ul>
</section>
<section id="gcc-podrška-po-kompajlerima" class="slide level2">
<h2>GCC podrška po kompajlerima</h2>
<table>
<thead>
<tr class="header">
<th>Od GCC verzije</th>
<th>Podržan OpenMP standard</th>
<th>Na jezicima</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4.2.0</td>
<td>2.5</td>
<td>C/C++/Fortran</td>
</tr>
<tr class="even">
<td>4.4.0</td>
<td>3</td>
<td>C/C++/Fortran</td>
</tr>
<tr class="odd">
<td>4.7.0</td>
<td>3.1</td>
<td>C/C++/Fortran</td>
</tr>
<tr class="even">
<td>4.9.0</td>
<td>4</td>
<td>C/C++</td>
</tr>
<tr class="odd">
<td>4.9.1</td>
<td>4</td>
<td>C/C++/Fortran</td>
</tr>
<tr class="even">
<td>6.1</td>
<td>4.5</td>
<td>C/C++</td>
</tr>
<tr class="odd">
<td>7</td>
<td>4.5</td>
<td>C/C++/Fortran</td>
</tr>
<tr class="even">
<td>11</td>
<td>5.0</td>
<td>C/C++</td>
</tr>
</tbody>
</table>
</section>
<section id="najosnovniji-openmp-program" class="slide level2">
<h2>Najosnovniji OpenMP program</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;omp.h&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="pp">#pragma omp parallel</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Hello World</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="napomena-pragme-nisu-u-stvari-magične."
class="slide level2">
<h2>Napomena: Pragme nisu, u stvari, magične.</h2>
<ul>
<li>Lako je zaboraviti da, koliko god da su zgodne za programiranje,
pragme i konstrukti paralelnog programiranja koje donose, sve se to i
dalje izvršava na istom procesoru kao i sav naš drugi kod.</li>
<li>Pre ili kasnije to postanu pozivi nad funkcijama, komande kontrole
toka itd.</li>
</ul>
</section>
<section id="pre-pragmi" class="slide level2">
<h2>Pre pragmi</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma omp parallel;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  body<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="posle-pragmi" class="slide level2">
<h2>Posle pragmi</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> subfunction<span class="op">(</span><span class="dt">void</span><span class="op">*</span> data<span class="op">){</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  use data<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  body<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>setup data<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>GOMP_parallel_start<span class="op">(</span>subfunction<span class="op">,</span> <span class="op">&amp;</span>data<span class="op">,</span> num_threads<span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>subfunction<span class="op">(&amp;</span>data<span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>GOMP_parallel_end<span class="op">();</span></span></code></pre></div>
</section>
<section id="napomena-pragme-nisu-u-stvari-magične.-1"
class="slide level2">
<h2>Napomena: Pragme nisu, u stvari, magične.</h2>
<ul>
<li>Ipak, ako mi sve dobro programiramo i ako je FSF sve dobro
programirao trebalo bi da ne moramo puno da mislimo o tome šta to OpenMP
radi iza kulisa.</li>
<li>Ne puno, ali pomalo.</li>
<li>Ne valja da zaboravimo da su naši alati <em>alati.</em></li>
</ul>
</section>
<section id="osnovna-sintaksa" class="slide level2">
<h2>Osnovna sintaksa</h2>
<ul>
<li>Svaka pragma za OpenMP počinje sa <code>#pragma omp</code></li>
<li>Zatim ide ključna reč pragme koja definiše šta ta pragma radi
praćena parametrima u zagradi (ako ih ima)</li>
<li>Moguće je pragme slagati u jednoj direktivi radi uštede
prostora.</li>
</ul>
</section>
<section id="pragma-parallel" class="slide level2">
<h2><code>#pragma parallel</code></h2>
<ul>
<li>Maksimalno račva izvršavanje pred ulazak u predstojeći izraz/blok i
izvršava ga u onoliko niti koliko je specificirano.</li>
<li>Nit se implicitno račva na početku, a sinhronizuje na kraju. `</li>
</ul>
</section>
<section id="pragma-private" class="slide level2">
<h2><code>#pragma private</code></h2>
<ul>
<li>Ova pragma definiše niz promenljivih (definisanih u nizu u
zagradama) kao privatne za nit koja ih koristi.</li>
<li>Navodi se posle ‘parallel’ direktive i odnosi se na niti tako
stvorene.</li>
</ul>
</section>
<section id="paralelna-for-petlja" class="slide level2">
<h2>Paralelna for petlja</h2>
<ul>
<li>Najčešća forma paralellizacije jeste podela iteracija for petlje
među nitima. Ako je svaki ciklus petlje nezavisan, onda stepen
paralelizma zavisi samo od ograničenja našeg hardvera.</li>
<li>Prirodno, OpenMP ima metode koje olakšavaju ovako nešto.</li>
</ul>
</section>
<section id="sekvencijalno-zbrajanje-nizova" class="slide level2">
<h2>Sekvencijalno zbrajanje nizova</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> nthreads<span class="op">,</span> threadid<span class="op">,</span> i<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> a<span class="op">[</span>N<span class="op">],</span> b<span class="op">[</span>N<span class="op">],</span> result<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span> <span class="op">*</span> i<span class="op">;</span> b<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> i<span class="op">;}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="paralelno-zbrajanje-nizova" class="slide level2">
<h2>Paralelno zbrajanje nizova</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> nthreads<span class="op">,</span> threadid<span class="op">,</span> i<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> a<span class="op">[</span>N<span class="op">],</span> b<span class="op">[</span>N<span class="op">],</span> result<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span> <span class="op">*</span> i<span class="op">;</span> b<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> i<span class="op">;}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="pp">#pragma omp parallel</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span><span class="co">//fork</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma omp for</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span><span class="co">//join</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="opservacije" class="slide level2">
<h2>Opservacije</h2>
<ul>
<li>Primetite da je paralelno izvršavanje i for petlja različita
stvar</li>
<li>Paralelno izvršavanje je baš to.</li>
<li>For petlja je konstrukt koji deli rad između niti.</li>
<li>Takođe, valja primetiti da je brojačka promenljiva automatski
privatna, što je zgodno.</li>
<li>Uprkos tome što su paralelizacija i for-deljenje odvojene operacije
moguće je (i poželjno je!) da ih pišemo zajedno</li>
</ul>
</section>
<section id="paralelno-zbrajanje-kraće" class="slide level2">
<h2>Paralelno zbrajanje, kraće</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> nthreads<span class="op">,</span> threadid<span class="op">,</span> i<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> a<span class="op">[</span>N<span class="op">],</span> b<span class="op">[</span>N<span class="op">],</span> result<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span> <span class="op">*</span> i<span class="op">;</span> b<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> i<span class="op">;}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="pp">#pragma omp parallel for</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="koliko-ima-niti-i-koja-radi-na-čemu" class="slide level2">
<h2>Koliko ima niti? I koja radi na čemu?</h2>
<ul>
<li>Ovde se valja podsetiti <code>OMP_SCHEDULE</code> promenljive.</li>
<li>Ona definiše podrazumevano ponašanje <code>for</code>
direktive.</li>
<li><code>SCHEDULE</code> mehanizam ima za cilj, jednostavno, da sve
indekse for petlje od 0 do N-1 podeli na neki broj regiona koji se ne
preklapaju.</li>
<li>Moguće je za svaku for petlju kontrolisati kako će to da uradi kroz
schedule direktivu koja u zagradama ima prvo ključnu reč a zatim
veličinu regiona.</li>
</ul>
</section>
<section id="ključne-reči-schedule-direktive" class="slide level2">
<h2>Ključne reči schedule direktive</h2>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>Ključna reč</th>
<th>Značenje</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>static</td>
<td>Iteracije se dele u komade veličine koja je specificirana, ako je
specificirana, u suprotnom se veličina računa tako što se ukupan broj
iteracija podeli brojem niti. Zatim se tako definisani regioni dele među
nitima koristeći “round robin” pristup.</td>
</tr>
<tr class="even">
<td>dynamic</td>
<td>Kao prethodno, ali osim na početku, niti se dele u first-come
first-served pristupu gde niti traže još posla kada završe rad.</td>
</tr>
<tr class="odd">
<td>guided</td>
<td>Kao prethodno, ali veličina regiona je fleksibilna i proporcionalna
je broju nedodeljenih iteracija podeljenih sa brojem dostupnih niti uz
minimum ravan podešenoj veličini regiona.</td>
</tr>
<tr class="even">
<td>auto</td>
<td>Kompajler/runtime bira šta se izvršava i kada.</td>
</tr>
<tr class="odd">
<td>runtime</td>
<td>Omogućava da se schedule podesi iz koda koristeći void
omp_set_schedule(omp_sched_t kind, int chunk_size);</td>
</tr>
</tbody>
</table>
</section>
<section id="monotono-i-nemonotono-izvršavanje" class="slide level2">
<h2>Monotono i nemonotono izvršavanje</h2>
<ul>
<li>Specifikaciju <code>schedule</code> direktive može pratiti ključna
reč <code>monotonic</code> i ključna reč <code>nonmonotonic</code>.</li>
<li><code>Monotonic</code> znači da svaka nit izvršava dodeljene
iteracije u redosledu strogo povećavajuće vrednosti brojača</li>
<li><code>Nonmonotonic</code> znači da svaka nit izvršava dodeljene
iteracije u proizvoljnom, nedeterminističkom redosledu.</li>
</ul>
</section>
<section id="alternativa-spmd-modelu-sekcije" class="slide level2">
<h2>Alternativa <code>SPMD</code> modelu: sekcije</h2>
<ul>
<li>Umesto da niti izvršavaju fundamentalno isti kod (nad različitim
podacima) kroz deljenje posla u nitima alternativa su sekcije.</li>
<li>Ideja je jednostavna: u okviru paralelnog regiona se napravi više
blokova anotiranih sa ‘section’ pragmom.</li>
<li>Među nitima se onda ravnomerno raspoređuju one koje rade različite
sekcije istovremeno i paralelni region se join-uje kada su sve sekcije
obavljene.</li>
<li>Očigledno, redosled izvršavanja apsolutno nije garantovan.</li>
</ul>
</section>
<section id="sekcije" class="slide level2">
<h2>Sekcije</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;omp.h&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="pp">#pragma omp parallel</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma omp sections</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">//nulti paralelni blok</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      <span class="pp">#pragma omp section</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//prvi paralelni blok</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      <span class="pp">#pragma omp section</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">//drugi parallelni blok</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="sinhronizacija" class="slide level2">
<h2>Sinhronizacija</h2>
<ul>
<li>OpenMP ima vrlo labavu komunikaciju između niti</li>
<li>To je potencijalno odlično budući da omogućava da kod koji je zamalo
isti kao sekvencijalni ima sve prednosti paralelizacije, i zaista, ako
samo koristimo paralelizaciju operacija u petljama nema šta puno da se
brinemo.</li>
<li>Dosta programa radi ovako. Numpy na primer: cela tajna je
multiprocesorsko jezgro za rad sa vektorima pisano u C-u koje se onda
koristi u fundamentalno sekvencijlanim algoritmima.</li>
<li>Ovo je maksimum koristi za minimum glavobolje.</li>
<li>Ali šta ako hoćemo još brzine i fleksibilnije algoritme?</li>
</ul>
</section>
<section id="sinhronizacija-1" class="slide level2">
<h2>Sinhronizacija</h2>
<ul>
<li>Onda moramo kontrolisati “labavu” komunikaciju između niti.</li>
<li>Treba da bude onoliko otvorena koliko može, naravno, ali nikako ne
preko toga.</li>
<li>U suprotnom imamo grozomorne probleme gde sav kod udara po istoj
memoriji i ona završi u nedefinisanom stanju.</li>
<li>Nedefinisana stanja valja izbeći.</li>
</ul>
</section>
<section id="nedefinisana-stanja" class="slide level2">
<h2>Nedefinisana stanja</h2>
<pre><code>ERROR: System attempted to parse HTML with regular expression; system returned Cthulhu.</code></pre>
</section>
<section id="uvećavanje-promenljive-kao-primer-haosa"
class="slide level2">
<h2>Uvećavanje promenljive kao primer haosa</h2>
<ul>
<li>Mi napišemo
<ul>
<li><code>Thread A: i++</code></li>
<li><code>Thread B: i++</code></li>
</ul></li>
<li>Mi dobijemo
<ul>
<li>A očita i sa vrednošću 7</li>
<li>B očita i sa vrednošću 7</li>
<li>B poveća 7 na 8 i smesti ga u i</li>
<li>A poveća 7 na 8 i smesti ga u i</li>
</ul></li>
<li>Komplikacija: Zbog toga kako procesori rade, ovo ne može da se desi
baš ovako, <em>možda,</em> ali je zgodan primer.</li>
</ul>
</section>
<section id="implicitna-sinhronziacija" class="slide level2">
<h2>Implicitna sinhronziacija</h2>
<ul>
<li>Svaki paralelni blok je implicitno sinhronizovan, budući da sve niti
moraju da sačekaju da se sve ostale niti završe pre nego se izvršavanje
nastavi.</li>
<li>Ovo omogućava da delimo izvršavanje na sekcije koje zavise jedna od
druge.</li>
<li>Centralni problem paralelizacije jeste, na kraju krajeva, to što u
sekvencijalnom izvršavanju relacija sekvence izvršavanja i relacija
zavisnosti su ista stvar.</li>
<li>Paralelizacija je razdvajanje te dve relacije gde je to moguće.</li>
<li>Negde, nešto mora da se završi da bi se kasniji deo koda izvršio
(nije moguće koristiti neki podataka pre nego što je izračunat osim jako
blizu površini horizonta Košija rotirajućih crnih rupa sa Kerovom
metrikom. Možda.)</li>
</ul>
</section>
<section id="eksplicitna-sinhronizacija" class="slide level2">
<h2>Eksplicitna sinhronizacija</h2>
<ul>
<li>Moguće je naterati niti da se sinhronizuju kroz direktive i to:
<ul>
<li>Direktiva kritičnog regiona</li>
<li>Direktiva glavne niti</li>
<li>Direktiva barijere</li>
<li>Direktiva jednostrukog izvršavanja</li>
</ul></li>
</ul>
</section>
<section id="direktiva-kritičnog-regiona" class="slide level2">
<h2>Direktiva kritičnog regiona</h2>
<ul>
<li>Direktiva kritičnog regiona (<code>#pragma omp critical</code>)
definiše blok koda kao kritičan.</li>
<li>Kritičan kod je takav da se u njemu u jednom trenutku može naći samo
jedna jedina nit.</li>
<li>Ovo nas štiti baš od onog problema sa inkrementacijom promenljive,
budući da sve što treba da uradimo jeste da se postaramo da je I++ u
kritičnom regionu i znamo da će cela operacija biti završena
odjednom.</li>
</ul>
</section>
<section id="direktiva-glavne-niti" class="slide level2">
<h2>Direktiva glavne niti</h2>
<ul>
<li>Direktiva glavne niti (<code>#pragma omp master</code>) definiše
blok koda koji je takav da ga može izvršiti samo i isključivo glavna
nit.</li>
<li>Svaka nit-radilica koja naleti na ovaj blok će ga ignorisati kao da
nije tu.</li>
<li>To znači da ovakav kod za razliku od većine sinhronizacija ne
usporava izvršavanje.</li>
</ul>
</section>
<section id="direktiva-barijere" class="slide level2">
<h2>Direktiva barijere</h2>
<ul>
<li>Direktiva barijere (<code>#pragma omp barrier</code>) služi da
natera niti da se sinhronizuju. Gde god da se stavi u kodu definiše
graničnu tačku.</li>
<li>Kada bilo koja nit stigne to granične tačke pauzira dok sve druge
niti nisu, takođe, stigle do granične tačke. Tek onda se izvršavanje
nastavlja.</li>
</ul>
</section>
<section id="direktiva-jednostrukog-izvršavanja" class="slide level2">
<h2>Direktiva jednostrukog izvršavanja</h2>
<ul>
<li>Direktiva jednostrukog izvršavanja (<code>#pragma omp single</code>)
definiše blok koda koji se izvršava u samo jednoj niti.</li>
<li>Radi kao direktiva glavne niti osim što:
<ul>
<li>Važi za prvu nit koja stigne do nje.</li>
<li>Zahteva sinhronizaciju na kraju bloka, tj. druge niti će čekati dok
se ne završi izvršavanje bloka pod direktivnom jednostrukog
izvršavanja.</li>
</ul></li>
<li>Ova druga razlika se može isključiti kroz upotrebu
<code>nowait</code> dodatka iza single direktive
(<code>#pragma omp single nowait</code>)</li>
</ul>
</section>
<section id="redukcija" class="slide level2">
<h2>Redukcija</h2>
<ul>
<li>Neke operacije su lake za paralelizaciju pošto uzimaju n ulaza a
proizvode n ili više izlaza koji su nezavisni.</li>
<li>Onda ih je lako iscepati na delove.</li>
<li>Recimo da hoćemo da izračunamo sinus svake vrednosti u nekom
ogromnom nizu: vrednost elementa 400494 ne zavisi od vrednosti elementa
403222 i nije bitno da li ih računa jedna nit ili više.</li>
<li>Šta kada imamo zavisnost?</li>
<li>Pa, ponekad ništa. Neki problemi jednostavno ne mogu da se
paralelizuju ili zahtevaju lukavstvo (kako paralelizovati računanje
Fibonačijevih brojeva?)</li>
<li>Ali ponekad je zavisnost malo pravilnija i moguće je koristiti za to
specijalizovane konstrukte.</li>
</ul>
</section>
<section id="pragma-reduction" class="slide level2">
<h2><code>#pragma reduction</code></h2>
<ul>
<li>Postoji <code>reduction</code> pragma sa sintaksom
<code>#pragma reduction(op : var)</code></li>
<li>Tu je <code>op</code> operator koji može biti:
<code>+, -, *, &amp;, |, ^, &amp;&amp; ||, min, max</code></li>
<li><code>var</code> je promenljiva za rezultat</li>
<li>Ima samo smisla u paralelnom kontekstu</li>
<li>Mora se odnositi na blok u kome se pojavljuje komad koda koji
izgleda ovako: <code>var = var op izraz</code></li>
</ul>
</section>
<section id="trivijalan-primer" class="slide level2">
<h2>Trivijalan primer</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;omp.h&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> a<span class="op">[</span>N<span class="op">],</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span> <span class="op">*</span> i<span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="pp">#pragma omp parallel for default(shared) private(i) schedule(static, 4) reduction(+ : s)</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> s <span class="op">+</span> a<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;S: </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> s<span class="op">);</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="posebne-redukcije" class="slide level2">
<h2>Posebne redukcije</h2>
<ul>
<li>Moguće je korišćenjem <code>declare reduction</code> omp pragme da
se definiše proizvoljni identifikator redukcije</li>
<li>On omogućava da se definišu nove redukcije bazirane na klauzuli
inicijalizacije i klauzuli koraka</li>
<li>To omogućava da se naprave redukcione operacije koje rade
proizvoljne stvari</li>
</ul>
</section>
<section id="posebne-redukcije-1" class="slide level2">
<h2>Posebne redukcije</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;omp.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> y<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> TVec2<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sum_struct<span class="op">(</span>TVec2 <span class="op">*</span>a<span class="op">,</span> TVec2 b<span class="op">){</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>x <span class="op">+=</span> b<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>y <span class="op">+=</span> b<span class="op">.</span>y<span class="op">;</span> </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sum_struct_init<span class="op">(</span>TVec2 <span class="op">*</span>o<span class="op">){</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    o<span class="op">-&gt;</span>x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    o<span class="op">-&gt;</span>y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="posebne-redukcije-2" class="slide level2">
<h2>Posebne redukcije</h2>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    TVec2 niz<span class="op">[</span><span class="dv">4096</span><span class="op">];</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    TVec2 sum<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma omp declare reduction(vecsum : TVec2 : </span><span class="op">\</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="pp">    sum_struct(&amp;omp_out, omp_in)) </span><span class="op">\</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="pp">    initializer (sum_struct_init(&amp;omp_priv))</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    sum<span class="op">.</span>x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    sum<span class="op">.</span>y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4096</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        niz<span class="op">[</span>i<span class="op">].</span>x <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        niz<span class="op">[</span>i<span class="op">].</span>y <span class="op">=</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</section>
<section id="posebne-redukcije-3" class="slide level2">
<h2>Posebne redukcije</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#pragma omp parallel for reduction(vecsum : sum)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4096</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        sum<span class="op">.</span>x <span class="op">+=</span> niz<span class="op">[</span>i<span class="op">].</span>x<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        sum<span class="op">.</span>y <span class="op">+=</span> niz<span class="op">[</span>i<span class="op">].</span>y<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Suma = (</span><span class="sc">%.2lf</span><span class="st">, </span><span class="sc">%.2lf</span><span class="st">)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> sum<span class="op">.</span>x<span class="op">,</span> sum<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="fibonačijevi-brojevi" class="slide level2">
<h2>Fibonačijevi brojevi?</h2>
<ul>
<li>Fibonačijevi brojevi su divan primer situacije gde tradicionalne
tehnike paralelizacije nisu osobito korisne.</li>
<li>Konvencionalni algoritam za njih je fundamentalno serijski.</li>
<li>Šta znači fundamentalno ovde?
<ul>
<li>N-ti korak zavisi od n-1 i n-2 koraka.</li>
<li>N-1 korak zavisi od n-2 i n-3 koraka</li>
<li>N-2 korak zavisi od n-3 i n-4 koraka</li>
<li>itd.</li>
</ul></li>
<li>Kako onda?
<ul>
<li>Varanje!</li>
</ul></li>
</ul>
</section>
<section id="varanje" class="slide level2">
<h2>Varanje</h2>
<ul>
<li>Reformulišemo problem tako da odgovara našim potrebama.</li>
<li>Postoji rekurzivna implementacija računanja fibonačijevog broja, ali
takođe postoji direktna formula <span class="math display">\[
F_n = \sum^{\lfloor\frac{n-1}{2}\rfloor}_{k=0}\binom{n-k-1}{k}
\]</span></li>
</ul>
</section>
<section id="varanje-1" class="slide level2">
<h2>Varanje</h2>
<ul>
<li>Da li ovo pomaže? Ne skroz. Računanje binomijalnih koeficijenata je
bazirano na računanju faktorijela što opet stvara umeren problem. Može
se paralelizovati (to je proizvod niza umesto sume), ali zahteva
ugnježdavanje paralelizama što može da bude nepotpuno podržano na našoj
arhitekturi.</li>
<li>Možemo da budemo direktniji, možda, naročito ako hoćemo da računamo
fibonačijeve brojeve zaredom.</li>
</ul>
</section>
<section id="varanje-2" class="slide level2">
<h2>Varanje</h2>
<p><span class="math inline">\(F(n+2) = F(n+1) + F(n)\)</span> i
naravno</p>
<p><span class="math inline">\(F(n+3) = F(n+2) + F(n+1) = 2 \cdot F(n+1)
+ F(n)\)</span></p>
<p><span class="math inline">\(F(n+4) = F(n+3) + F(n+2) = 3 \cdot F(n+1)
+ 2 \cdot F(n)\)</span></p>
<p><span class="math inline">\(F(n+5) = F(n+4) + F(n+3) = 5 \cdot F(n+1)
+ 3 \cdot F(n)\)</span></p>
<p><span class="math inline">\(F(n+6) = F(n+3) + F(n+2) = 8 \cdot F(n+1)
+ 5 \cdot F(n)\)</span></p>
</section>
<section id="varanje-3" class="slide level2">
<h2>Varanje</h2>
<p>Stoga, uopšteno: <span class="math display">\[
F(n+k) = F(n+1) \cdot F(k) + F(n) \cdot F(k-1)
\]</span></p>
</section>
<section id="varanje-4" class="slide level2">
<h2>Varanje</h2>
<ul>
<li>Sada je naš zadatak jednostavan: izračunamo m Fibonačijevih brojeva
i čuvamo ih u memoriji</li>
<li>Zatim sve brojevo od <span class="math inline">\(m+1\)</span> do
<span class="math inline">\(2m\)</span> računamo u <span
class="math inline">\(m\)</span>-tostrukoj paraleli uzimajući <span
class="math inline">\(n = m\)</span> a <span class="math inline">\(k =
1..m\)</span>.</li>
<li>Onda samo pomerimo da je <span class="math inline">\(n =
2m+1\)</span> i ponovimo proces</li>
<li>Drugim rečima, naš algoritam je serijski korak prekomputacije, a
zatim serijsko ponavljanje m-tostruko paralelizovanog računanja bloka
vrednosti</li>
<li>Stepen paralelizacije je, onda, praktično neograničen.</li>
<li>Pobeda!</li>
<li>Više o ovakvim egzibicijama za čas-dva</li>
</ul>
</section></section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/math/math.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [
          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
